"""
XML Worker - –û–î–ò–ù –§–ê–ô–õ —Å–æ –≤—Å–µ–π –ª–æ–≥–∏–∫–æ–π –∫–∞–∫ –≤ —Ä–∞–±–æ—á–µ–º pipeline.py
"""
import os
import socket
import time
import logging
import asyncio
from typing import List
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import httpx

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(name)s: %(message)s'
)
logger = logging.getLogger("app.main")

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑ ENV
WORKER_ID = os.getenv("WORKER_ID", "unknown")
LOGIN_NAME = os.getenv("LOGIN_NAME", "")
LOGIN_KEY = os.getenv("LOGIN_KEY", "")
API_MOTHER_URL = os.getenv("API_MOTHER_URL", "http://host-api-service-api_mother-1:8083")

if not LOGIN_NAME or not LOGIN_KEY:
    raise ValueError("LOGIN_NAME –∏ LOGIN_KEY –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã!")

logger.info(f"XML Worker {WORKER_ID} –∑–∞–ø—É—â–µ–Ω —Å –∞–∫–∫–∞—É–Ω—Ç–æ–º: {LOGIN_NAME}")

app = FastAPI(title=f"XML Worker {WORKER_ID}")

# –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ (–∫–∞–∫ –≤ –≤–∞—à–µ–º —Å–∫—Ä–∏–ø—Ç–µ - –û–î–ù–û —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö batch)
sock = None
is_authenticated = False


def connect_and_auth():
    """–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è - –¢–û–ß–ù–ê–Ø –ö–û–ü–ò–Ø –∏–∑ –≤–∞—à–µ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞"""
    global sock, is_authenticated
    
    host = "185.92.72.18"
    port = 5190
    login_template = '<LOGIN v3="10.20.30.40" lang="ru" v2="4875537" v="108" p="{key}" l="{login_name}" />\x00'
    
    logger.info(f"–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ {host}:{port} (–∞–∫–∫–∞—É–Ω—Ç: {LOGIN_NAME})")
    
    sock = socket.create_connection((host, int(port)), timeout=10)
    
    # –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
    login_xml = login_template.format(key=LOGIN_KEY, login_name=LOGIN_NAME)
    sock.sendall(login_xml.encode('utf-8'))
    
    # –ü–æ–ª—É—á–∞–µ–º OK
    sock.recv(8192)
    
    # –û—Ç–ø—Ä–∞–≤–∫–∞ GETME
    sock.sendall("<GETME />\x00".encode('utf-8'))
    
    # –ü—Ä–æ—Å—Ç–æ –∂–¥—ë–º —á—Ç–æ–±—ã MYPARAM –ø—Ä–∏—à—ë–ª (–Ω–µ —á–∏—Ç–∞–µ–º –±—É—Ñ–µ—Ä!)
    time.sleep(1.5)
    
    is_authenticated = True
    logger.info("‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")


@app.on_event("startup")
async def startup_event():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ"""
    await asyncio.to_thread(connect_and_auth)
    logger.info(f"‚úÖ Worker {WORKER_ID} –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ —Å–µ—Ä–≤–µ—Ä—É")


@app.on_event("shutdown")
async def shutdown_event():
    """–ó–∞–∫—Ä—ã—Ç–∏–µ"""
    logger.info(f"Worker {WORKER_ID} –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∞–±–æ—Ç—É")


class FetchResponse(BaseModel):
    battle_id: int
    status: str
    error: str | None = None
    size_bytes: int | None = None
    uploaded_to_mother: bool = False


class BatchFetchRequest(BaseModel):
    battle_ids: List[int]
    max_parallel: int = 1
    upload_to_mother: bool = True


class BatchFetchResponse(BaseModel):
    results: List[FetchResponse]
    total: int
    success: int
    failed: int
    timeout: int


@app.get("/health")
async def health():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è"""
    return {
        "status": "healthy" if is_authenticated else "degraded",
        "worker_id": WORKER_ID,
        "login": LOGIN_NAME,
        "authenticated": is_authenticated
    }


@app.post("/fetch_batch", response_model=BatchFetchResponse)
async def fetch_battle_batch(request: BatchFetchRequest):
    """
    –ü–æ–ª—É—á–∏—Ç—å –ø–∞—á–∫—É –±–æ—ë–≤ - –¢–û–ß–ù–ê–Ø –ö–û–ü–ò–Ø –ª–æ–≥–∏–∫–∏ –∏–∑ download_battles_pipeline
    """
    global sock, is_authenticated
    
    if not is_authenticated or not sock:
        raise HTTPException(status_code=503, detail="–ù–µ –ø–æ–¥–∫–ª—é—á–µ–Ω")
    
    logger.info(f"üì¶ Pipeline batch: {len(request.battle_ids)} –±–æ–µ–≤")
    
    battle_ids = request.battle_ids
    batch_size = len(battle_ids)
    output_dir = "/srv/btl/raw"
    
    try:
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ –∫–æ–º–∞–Ω–¥—ã –ø–∞—á–∫–∏
        for battle_id in battle_ids:
            sock.sendall(f'<POST t="//blook {battle_id}" />\x00'.encode('utf-8'))
            time.sleep(0.05)
            sock.sendall("<GETMYBATTLE />\x00".encode('utf-8'))
            time.sleep(0.05)
        
        # Keep-alive
        sock.sendall("<N />\x00".encode('utf-8'))
        
        # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç—ã
        buffer = b''
        sock.settimeout(30)
        start_time = time.time()
        max_time = 30
        
        while time.time() - start_time < max_time:
            try:
                chunk = sock.recv(16384)
                if chunk:
                    buffer += chunk
                    blook_close = buffer.count(b'</BLOOK>')
                    
                    if blook_close >= batch_size:
                        sock.settimeout(2)
                        try:
                            extra = sock.recv(16384)
                            if extra:
                                buffer += extra
                        except socket.timeout:
                            pass
                        break
                else:
                    break
            except socket.timeout:
                if buffer.count(b'</BLOOK>') >= batch_size:
                    break
                continue
        
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ: {buffer.count(b'</BLOOK>')} BLOOK")
        
        # –î–µ–∫–æ–¥–∏—Ä—É–µ–º
        decoded = buffer.decode('utf-8', errors='replace')
        decoded = decoded.replace('\x00', '').replace('\x1f', '')
        
        # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ BLOOK
        blooks = []
        pos = 0
        while True:
            start = decoded.find('<BLOOK>', pos)
            if start == -1:
                break
            end = decoded.find('</BLOOK>', start)
            if end == -1:
                blooks.append(decoded[start:])
                break
            end += len('</BLOOK>')
            blooks.append(decoded[start:end])
            pos = end
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º
        success_count = 0
        results = []
        saved_files = []
        
        for idx, blook_xml in enumerate(blooks):
            if idx < len(battle_ids):
                battle_id = battle_ids[idx]
                shard = battle_id // 50000
                shard_dir = os.path.join(output_dir, str(shard))
                os.makedirs(shard_dir, exist_ok=True)
                filename = os.path.join(shard_dir, f"{battle_id}.tzb")
                
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(blook_xml)
                
                size_kb = len(blook_xml) / 1024
                logger.info(f"‚úì {battle_id}.tzb ({size_kb:.1f} KB)")
                success_count += 1
                saved_files.append(filename)
                
                results.append(FetchResponse(
                    battle_id=battle_id,
                    status="success",
                    size_bytes=len(blook_xml),
                    uploaded_to_mother=False
                ))
        
        # –ù–µ–ø–æ–ª—É—á–µ–Ω–Ω—ã–µ
        for battle_id in battle_ids[success_count:]:
            results.append(FetchResponse(
                battle_id=battle_id,
                status="failed",
                error="–ù–µ –ø–æ–ª—É—á–µ–Ω –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞"
            ))
        
        failed_count = batch_size - success_count
        if failed_count > 0:
            logger.warning(f"–ù–µ –ø–æ–ª—É—á–µ–Ω–æ: {failed_count} –±–æ—ë–≤")
        
        logger.info(f"Pipeline: {success_count} —É—Å–ø–µ—à–Ω–æ, {failed_count} –æ—à–∏–±–æ–∫")
        
        # Upload –≤ mother –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        uploaded_count = 0
        if request.upload_to_mother and saved_files:
            async with httpx.AsyncClient(timeout=30.0) as http_client:
                for file_path in saved_files:
                    try:
                        battle_id = int(os.path.basename(file_path).replace('.tzb', ''))
                        
                        with open(file_path, 'r', encoding='utf-8') as f:
                            xml_content = f.read()
                        
                        response = await http_client.post(
                            f"{API_MOTHER_URL}/upload/{battle_id}",
                            content=xml_content,
                            headers={"Content-Type": "application/xml"}
                        )
                        
                        if response.status_code == 200:
                            uploaded_count += 1
                            for res in results:
                                if res.battle_id == battle_id:
                                    res.uploaded_to_mother = True
                                    break
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ upload –≤ mother: {e}")
        
        logger.info(f"üì§ –ó–∞–≥—Ä—É–∂–µ–Ω–æ –≤ mother: {uploaded_count}/{success_count}")
        
        # –ü–∞—É–∑–∞ –º–µ–∂–¥—É batch (–∫–∞–∫ –≤ –≤–∞—à–µ–º —Å–∫—Ä–∏–ø—Ç–µ)
        await asyncio.sleep(0.3)
        
        return BatchFetchResponse(
            results=results,
            total=batch_size,
            success=success_count,
            failed=failed_count,
            timeout=0
        )
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞: {e}")
        import traceback
        traceback.print_exc()
        
        results = [
            FetchResponse(battle_id=bid, status="failed", error=str(e))
            for bid in battle_ids
        ]
        
        return BatchFetchResponse(
            results=results,
            total=batch_size,
            success=0,
            failed=batch_size,
            timeout=0
        )


if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", "9000"))
    uvicorn.run(app, host="0.0.0.0", port=port)
