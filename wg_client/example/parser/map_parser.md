# map_parser.md

> **Коротко:** мы храним базовую карту по `map_id`, а в JSON передаём лишь **делту (diff)** — минимальный набор правок (полосы и точки). Это делает полезную нагрузку в разы короче. Формат детерминированный, легко воспроизводимый в любой среде.

---

## 1) Термины и базовая модель (актуализация под battle_parser)

- **Карта** — набор строк фиксированной длины (например, `H=26` строк по `W=48` символов). Каждая строка соответствует значению из атрибута `<MAP v="..."/>` в первом блоке `<BATTLE>` после дедупликации.
- **Базовая карта** — эталон, на который мы ссылаемся коротким идентификатором `map_id`.
- **Дельта (diff)** — компактное описание отличий новой карты от базовой.

### Требования к алфавиту
- Символы в `v` — однобайтные (ASCII-совместимые) либо заранее согласованный набор Unicode-символов.  
- Все символы новой карты должны быть допустимыми для движка игры.

---

## 2) Минимальный JSON-формат (ID + diffs) и размещение в JSON боя

**Идея:** в JSON хранится только ссылка на базовую карту (`i`) и набор правок (`d`).

```jsonc
{
  "i": "m_8fx3a92",      // map_id: blake2s8(строки MAP, \n-склейка), верхний HEX
  "d": {
    "r": [[y0, y1, x0, x1, "ch"]],             // прямоугольники (опционально)
    "h": [[y, x0, x1, "ch"]],                  // горизонтальные полосы
    "s": [[y, x, "ch"]]                        // одиночные точки
  },
  "cs": "blake2s8:7E4AF962B2F32981"            // контрольная сумма результата (совпадает с i без префикса m_)
}
В итоговом JSON боя `map_patch` размещён внутри объекта `battle`:

```json
"battle": {
  ...,
  "map_patch": { "i": "m_<HEX>", "cs": "blake2s8:<HEX>", "d": { /* опционально */ } }
}
```
```

### Порядок применения
1. `r` (прямоугольники), затем
2. `h` (горизонтали), затем
3. `s` (точки).

Поздние операции имеют **приоритет** над ранними (локальные уточнения поверх крупных заливок).

### Почему три типа операций
- `r` — дешёво выражает большие заливки (если встречаются).
- `h` — лучший компромисс для «дорожек» и частых линейных изменений.
- `s` — «добивает» редкие точки, где полосы неэффективны.

> Если `r` не используете — можно убрать из схемы. Базовый вариант работает только с `h` и `s`.

---

## 3) Формальная схема (JSON Schema draft-07)

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "MapPatch",
  "type": "object",
  "required": ["i"],
  "properties": {
    "i": { "type": "string", "minLength": 1, "maxLength": 64 },
    "d": {
      "type": "object",
      "properties": {
        "r": {
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 5,
            "maxItems": 5,
            "items": [
              { "type": "integer", "minimum": 0 },   // y0
              { "type": "integer", "minimum": 0 },   // y1
              { "type": "integer", "minimum": 0 },   // x0
              { "type": "integer", "minimum": 0 },   // x1
              { "type": "string",  "minLength": 1, "maxLength": 1 } // ch
            ]
          }
        },
        "h": {
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 4,
            "maxItems": 4,
            "items": [
              { "type": "integer", "minimum": 0 },   // y
              { "type": "integer", "minimum": 0 },   // x0
              { "type": "integer", "minimum": 0 },   // x1
              { "type": "string",  "minLength": 1, "maxLength": 1 } // ch
            ]
          }
        },
        "s": {
          "type": "array",
          "items": {
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": [
              { "type": "integer", "minimum": 0 },   // y
              { "type": "integer", "minimum": 0 },   // x
              { "type": "string",  "minLength": 1, "maxLength": 1 } // ch
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "cs": { "type": "string" }
  },
  "additionalProperties": false
}
```

---

## 4) Применение патча (алгоритм)

**Вход:** базовая карта `rows_base` (список строк), JSON патча `patch`.  
**Выход:** новая карта `rows_new`.

Псевдокод:

```text
rows := копия rows_base (как список списков символов)

для каждого (y0, y1, x0, x1, ch) из patch.d.r:
  для y в [y0..y1]:
    для x в [x0..x1]:
      rows[y][x] := ch

для каждого (y, x0, x1, ch) из patch.d.h:
  для x в [x0..x1]:
    rows[y][x] := ch

для каждого (y, x, ch) из patch.d.s:
  rows[y][x] := ch

rows_new := склейка строк из rows
```

### Валидация и границы
- Проверяйте, что индексы не выходят за `0 ≤ y < H`, `0 ≤ x < W` и `x0 ≤ x1`, `y0 ≤ y1`.
- Символ `ch` должен быть из допустимого алфавита.

### Контрольная сумма
- По желанию — вычисляйте хеш (например, `blake2s` 8 байт) от `"\n".join(rows_new)` и сравнивайте с `cs`.
- Поле `cs` — строка в формате `algoHEX:HEX` или `algoB64:B64` (на ваш выбор).

---

## 5) Генерация diffs (из двух карт)

Задача: для `rows_base` и `rows_new` построить минимальный (или близкий к минимальному) `diff`.  
Простой и быстрый метод — **горизонтальные полосы + точки**.

### Алгоритм (горизонтальные полосы)
1. Для каждой строки `y` сравниваем `base[y]` и `new[y]` посимвольно.
2. Как только обнаружена разница, запоминаем `x0 = x` и текущий символ `ch = new[y][x]`.
3. Двигаемся вправо, пока `new[y][x] == ch` и `base[y][x] != new[y][x]` — это полоса `[x0..x1]`.
4. Если длина `L = x1 - x0 + 1 ≥ T` (порог, рекомендуем `T=3`), добавляем в `h`; иначе — разбиваем на точки в `s`.

```python
def build_diff(base_rows, new_rows, T=3):
    H, W = len(base_rows), len(base_rows[0])
    h, s = [], []
    for y in range(H):
        a, b = base_rows[y], new_rows[y]
        x = 0
        while x < W:
            if a[x] == b[x]:
                x += 1; continue
            ch = b[x]; x0 = x
            while x < W and b[x] == ch and a[x] != b[x]:
                x += 1
            x1 = x - 1
            if x1 - x0 + 1 >= T:
                h.append([y, x0, x1, ch])
            else:
                for xx in range(x0, x1 + 1):
                    s.append([y, xx, ch])
    diff = {}
    if h: diff["h"] = h
    if s: diff["s"] = s
    return diff
```

### Прямоугольники (опционально)
Если часто встречаются «заливки», можно искать прямоугольники одного символа. Грубая эвристика:
1. По каждой строке соберите полосы или «пятна» символа `ch`.
2. Вертикально склейте соседние строки с совпадающими интервалами `[x0..x1]` и тем же `ch`.
3. Если площадь `S = (y1-y0+1)*(x1-x0+1)` даёт ощутимую экономию — оформляйте как `r`.

> Эвристика полезна, но не обязательна: базовый формат работает и без `r`.

---

## 6) Расширенный формат (ультракоротко): бинарный патч + Base32768

Если нужен **ещё короче**, можно упаковать патчи в бинарный поток и кодировать его как **строку Unicode** (Base32768). В JSON будет **одна строка** вместо массивов.

### Спецификация бинарного патча v1 (MPB1)
- **Заголовок:** ASCII `"MPB1"`
- **Тело:** последовательность инструкций, каждая начинается 1 байтом **op**:
  - `0x52 'R'`: `u16 y0, u16 y1, u16 x0, u16 x1, u8 ch`
  - `0x48 'H'`: `u16 y,  u16 x0, u16 x1, u8 ch`
  - `0x53 'S'`: `u16 y,  u16 x,      u8 ch`
  - `0x45 'E'`: конец потока (опционально; можно завершать по длине)
- **Сжатие:** `zlib(level=9)`
- **Текстовое кодирование:** Base32768 (15 бит/символ, безопасные BMP-диапазоны)

JSON-пример:
```json
{
  "i": "m_8fx3a92",
  "p_b": "B32768Z:……строка из 200–300 символов……",
  "cs": "blake2s8:7E4AF962B2F32981"
}
```

Плюсы: в 2–3 раза короче, чем обычный `d` с массивами. Минус: сложнее дебажить глазами (поэтому часто оставляют оба варианта: `d` для dev, `p_b` для prod).

---

## 7) Примеры кода (Python)

### Применение `d` к базовой карте
```python
def apply_patch(rows, patch):
    rows2 = [list(r) for r in rows]
    d = patch.get("d", {})
    for y0, y1, x0, x1, ch in d.get("r", []):
        for y in range(y0, y1 + 1):
            for x in range(x0, x1 + 1):
                rows2[y][x] = ch
    for y, x0, x1, ch in d.get("h", []):
        for x in range(x0, x1 + 1):
            rows2[y][x] = ch
    for y, x, ch in d.get("s", []):
        rows2[y][x] = ch
    return ["".join(r) for r in rows2]
```

### Построение `d` из двух карт
(см. алгоритм выше — функция `build_diff`)

### Контрольная сумма (blake2s → 8 байт hex)
```python
from hashlib import blake2s

def checksum(rows):
    data = "\n".join(rows).encode("utf-8")
    h = blake2s(data, digest_size=8).hexdigest().upper()
    return f"blake2s8:{h}"
```

### Бинарный патч MPB1 → Base32768
```python
import zlib, struct

# Таблица Base32768
RANGES = [(0x4E00,0x9FFF), (0xAC00,0xD7A3), (0x3400,0x36A3)]
TABLE = [cp for a,b in RANGES for cp in range(a, b+1)]
REV   = {cp:i for i,cp in enumerate(TABLE)}

def to_b32768(data: bytes) -> str:
    bits = n = 0; out = []
    for b in data:
        bits = (bits<<8) | b; n += 8
        while n >= 15:
            n -= 15; out.append(chr(TABLE[(bits>>n) & 0x7FFF])); bits &= (1<<n)-1
    if n: out.append(chr(TABLE[(bits<<(15-n)) & 0x7FFF]))
    return "".join(out)

def from_b32768(s: str) -> bytes:
    bits = n = 0; out = bytearray()
    for ch in s:
        v = REV[ord(ch)]
        bits = (bits<<15) | v; n += 15
        while n >= 8:
            n -= 8; out.append((bits>>n) & 0xFF); bits &= (1<<n)-1
    return bytes(out)

def encode_mpb1(d):
    buf = bytearray(b"MPB1")
    for y0,y1,x0,x1,ch in d.get("r", []):
        buf += b"R" + struct.pack("<HHHHB", y0,y1,x0,x1, ord(ch))
    for y,x0,x1,ch in d.get("h", []):
        buf += b"H" + struct.pack("<HHHB", y,x0,x1, ord(ch))
    for y,x,ch in d.get("s", []):
        buf += b"S" + struct.pack("<HHB", y,x, ord(ch))
    comp = zlib.compress(bytes(buf), 9)
    return "B32768Z:" + to_b32768(comp)

def decode_mpb1(token):
    assert token.startswith("B32768Z:")
    comp = from_b32768(token[9:])
    data = zlib.decompress(comp)
    assert data[:4] == b"MPB1"
    i = 4; d = {"r": [], "h": [], "s": []}
    while i < len(data):
        op = data[i]; i += 1
        if op == ord("R"):
            y0,y1,x0,x1,ch = struct.unpack_from("<HHHHB", data, i); i += 9
            d["r"].append([y0,y1,x0,x1, chr(ch)])
        elif op == ord("H"):
            y,x0,x1,ch = struct.unpack_from("<HHHB", data, i); i += 7
            d["h"].append([y,x0,x1, chr(ch)])
        elif op == ord("S"):
            y,x,ch = struct.unpack_from("<HHB", data, i); i += 5
            d["s"].append([y,x, chr(ch)])
        else:
            raise ValueError("Unknown opcode")
    # очистить пустые
    return {k:v for k,v in d.items() if v}
```

---

## 8) Версионирование и совместимость

- У JSON-формата можно зафиксировать поле `"v": 1` при необходимости.
- Для бинарного патча **подпись `"MPB1"`** — это номер версии.
- Рекомендуется:
  - не добавлять новые поля без `additionalProperties: false` контроля;
  - любые расширения вводить через новые ключи или новую версию подписи.

---

## 9) Валидация и ошибки

- Проверка границ индексов (`x0≤x1`, `y0≤y1`, диапазоны `x,y`).
- Проверка алфавита символов.
- Конфликты операций: т.к. порядок фиксирован (`r`→`h`→`s`), конфликты трактуются детерминированно — более поздняя операция перезапишет раннюю.
- Проверка `cs` (если задан): несоответствие — ошибка сборки патча.

---

## 10) Тест-кейсы (минимальные)

> Формат как вы просили — в Markdown.

**TC1. Пустой diff**  
- base = new; `d` отсутствует.  
- Ожидание: `apply_patch` возвращает точную копию.

**TC2. Горизонтальная полоса**  
- В одной строке `y=5` символы `[x=10..20]` заменены на `Z`.  
- Ожидание: запись одной `h` и корректная сборка.

**TC3. Разрежённые различия**  
- В разных строках по 1 символу.  
- Ожидание: только `s`, без `h` (если `T=3`).

**TC4. Перекрытие `r` и `h`**  
- Сначала `r` заливает прямоугольник, затем `h` частично его меняет.  
- Ожидание: финальная карта соответствует `h` на пересечении.

**TC5. Контрольная сумма**  
- После применения `d` хеш совпадает с `cs`.  
- При умышленном искажении `d` — несоответствие `cs` и ошибка.

---

## 11) Практические рекомендации

- Для продакшена, где критичен размер JSON:
  - используйте **`p_b`** (MPB1 + zlib + Base32768) — одна короткая строка;
  - параллельно храните человекочитаемый `d` для дебага/логов.
- Для CI/билда: запускать «сверку» `apply_patch(base, d)` с эталоном и валидировать `cs`.
- Для масштабов (много карт): заведите **контент-адресуемое хранилище** базовых карт (по хешу) + индекс `map_id → hash`.

---

## 12) Часто задаваемые вопросы (FAQ)

- **Нужны ли ширина/высота в JSON?**  
  Нет, они известны по базовой карте. В `p_b` тоже не нужны — патч применим к базе по `map_id`.

- **Как выбрать `map_id`?**  
  Короткий префикс хеша (`blake2s`/`sha1`) или инкрементный артикул. Главное — уникальность.

- **Можно ли делать смешанные символы (Unicode)?**  
  Да, если игровой движок их поддерживает. Важно согласовать алфавит.

- **Почему Base32768?**  
  Каждый символ несёт 15 бит данных, поэтому строка короче; при этом остаёмся в BMP (без суррогатов), JSON/UTF-8 проходит стабильно.

---

## 13) Мини-глоссарий

- **H,W** — высота/ширина карты.
- **row** — строка карты (значение `v` из `<MAP v="..."/>`).
- **diff** — набор операций, преобразующих базу в целевую карту.
- **patch** — JSON-объект с `i`, `d` (и опционально `cs`) или бинарная форма `p_b`.

---

Готово. Этот документ описывает полный цикл: структуру данных, правила сборки, форматы JSON и бинарного патча, алгоритмы генерации diffs и их применение, а также примеры кода и тест-кейсы. Любая ИИ/сервис сможет воспроизвести поведение один-в-один.
